<!-- Inline JS for chat functionality and input auto-resize -->
<script>
  const form = document.getElementById('chat-form');
  const userInput = document.getElementById('user-input');
  const messageList = document.getElementById('message-list');

  // Auto-resize the textarea as the user types.
  userInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = this.scrollHeight + 'px';
  });

  // Use marked to parse markdown text.
  function renderMarkdown(text) {
    return marked.parse(text);
  }

  // Escape HTML so that literal tags appear.
  function escapeHTML(str) {
    return str.replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
  }

  // Function to add copy buttons to code blocks within a given container.
  function addCopyButtons(container) {
    const codeBlocks = container.querySelectorAll("div.code-block");
    codeBlocks.forEach((block) => {
      if (block.querySelector(".copy-button")) return;
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-button");
      copyButton.textContent = "Copy";
      copyButton.setAttribute("aria-label", "Copy code");
      copyButton.addEventListener("click", () => {
        const codeElement = block.querySelector("pre code");
        if (!codeElement) return;
        const codeText = codeElement.textContent;
        navigator.clipboard.writeText(codeText)
          .then(() => {
            copyButton.textContent = "Copied!";
            setTimeout(() => { copyButton.textContent = "Copy"; }, 2000);
          })
          .catch(() => {
            copyButton.textContent = "Error";
          });
      });
      block.style.position = "relative";
      block.appendChild(copyButton);
    });
  }

  // Key binding: Allow Ctrl+Enter (or Command+Enter) to send the message.
  userInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      form.dispatchEvent(new Event('submit', {cancelable: true}));
    }
  });

  // --- NEW: Tuned Auto-Scroll Function ---
  // Rather than maintaining a flag, we simply check the current distance from the bottom.
  // If the user is near the bottom (within threshold), we auto-scroll.
  let autoScrollTimer;
  function maybeAutoScroll() {
    clearTimeout(autoScrollTimer);
    autoScrollTimer = setTimeout(() => {
      const threshold = 50; // pixels from the bottom to consider "near"
      const distanceFromBottom = messageList.scrollHeight - messageList.scrollTop - messageList.clientHeight;
      if (distanceFromBottom <= threshold) {
        messageList.scrollTop = messageList.scrollHeight;
      }
    }, 50);
  }
  // --- End Auto-Scroll Function ---

  // Append a new message to the message list.
  // (The unchanged parts of this function are omitted for brevity.)
  function appendMessage(text, sender, isThinking = false) {
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('message', sender);
    msgDiv.style.margin = "0.5rem 0";
    msgDiv.style.padding = "0.5rem 0.75rem";
    msgDiv.style.borderRadius = "4px";
    msgDiv.style.wordWrap = "break-word";

    if (sender === 'user') {
      msgDiv.style.background = "#e0f7fa";
      msgDiv.style.textAlign = "right";
      msgDiv.innerHTML = renderMarkdown(text);
    } else if (sender === 'bot' && isThinking) {
      // [existing logic for creating a bot message with "thinking" and "thoughts" sections]
      const container = document.createElement('div');
      container.classList.add('bot-message-container');

      // Create the thoughts container.
      const thoughtsContainer = document.createElement('div');
      thoughtsContainer.classList.add('thoughts-container');

      // Header with toggle icon on the left.
      const thoughtsHeader = document.createElement('div');
      thoughtsHeader.classList.add('thoughts-header');
      thoughtsHeader.style.fontStyle = "italic";
      const toggleIcon = document.createElement('span');
      toggleIcon.classList.add('toggle-icon');
      toggleIcon.textContent = '[+] ';
      thoughtsHeader.appendChild(toggleIcon);
      const headerLabel = document.createElement('span');
      headerLabel.textContent = 'Thinking';
      headerLabel.id = 'thoughts-label';
      thoughtsHeader.appendChild(headerLabel);
      thoughtsContainer.appendChild(thoughtsHeader);

      // Container for the raw thinking block (with <think> tags preserved).
      const thoughtsContent = document.createElement('div');
      thoughtsContent.classList.add('thoughts-content');
      thoughtsContent.style.display = 'none';
      thoughtsContent.style.marginTop = "0.5rem";
      thoughtsContent.style.padding = "0.5rem";
      thoughtsContent.style.border = "1px solid #ddd";
      thoughtsContent.style.background = "#f4f4f4";
      thoughtsContainer.appendChild(thoughtsContent);

      container.appendChild(thoughtsContainer);

      // Container for the main answer.
      const mainContentDiv = document.createElement('div');
      mainContentDiv.classList.add('main-content');
      container.appendChild(mainContentDiv);

      msgDiv.appendChild(container);
      messageList.appendChild(msgDiv);
      maybeAutoScroll();

      // Save references for later updates.
      msgDiv._mainContentDiv = mainContentDiv;
      msgDiv._thoughtsContent = thoughtsContent;
      msgDiv._thoughtsHeader = headerLabel;
      msgDiv._toggleIcon = toggleIcon;
      
      // Toggle event listener for the thoughts header.
      thoughtsHeader.addEventListener('click', () => {
        if (thoughtsContent.style.display === 'none') {
          thoughtsContent.style.display = 'block';
          toggleIcon.textContent = '[-] ';
        } else {
          thoughtsContent.style.display = 'none';
          toggleIcon.textContent = '[+] ';
        }
      });
      return msgDiv;
    } else {
      msgDiv.innerHTML = renderMarkdown(text);
    }
    messageList.appendChild(msgDiv);
    maybeAutoScroll();
    return msgDiv;
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const question = userInput.value.trim();
    if (!question) return;
    appendMessage(question, 'user');
    userInput.value = '';

    // Append an empty bot message in thinking mode.
    const botMsgDiv = appendMessage('', 'bot', true);

    // Variables for streamed content.
    let thinkingBlock = "";  // full raw <think> block (with tags)
    let mainContent = "";    // final answer text
    let inThinkBlock = false;

    try {
      const response = await fetch('https://venice-backend-14aff752beac.herokuapp.com/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: question }),
      });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        let lines = buffer.split("\n");
        buffer = lines.pop();
        for (let line of lines) {
          if (!line.startsWith("data: ")) continue;
          const jsonStr = line.slice(6).trim();
          if (jsonStr === "[DONE]") continue;
          try {
            const data = JSON.parse(jsonStr);
            let token = (data.choices && data.choices[0] && data.choices[0].delta && data.choices[0].delta.content) || "";
            if (!token) continue;
            // Detect the start of a thinking block.
            if (token.indexOf("<think>") !== -1 && !inThinkBlock) {
              inThinkBlock = true;
            }
            if (inThinkBlock) {
              thinkingBlock += token;
              if (botMsgDiv._thoughtsContent) {
                botMsgDiv._thoughtsContent.innerHTML = escapeHTML(thinkingBlock);
              }
              if (token.indexOf("</think>") !== -1) {
                inThinkBlock = false;
                if (botMsgDiv._thoughtsHeader) {
                  botMsgDiv._thoughtsHeader.textContent = "Thoughts";
                }
              }
            } else {
              mainContent += token;
              if (botMsgDiv._mainContentDiv) {
                botMsgDiv._mainContentDiv.innerHTML = renderMarkdown(mainContent);
                // Wrap <pre><code> blocks in a container if not already.
                botMsgDiv._mainContentDiv.querySelectorAll("pre").forEach(pre => {
                  if (!pre.parentElement.classList.contains("code-block")) {
                    const wrapper = document.createElement("div");
                    wrapper.classList.add("code-block");
                    pre.parentElement.insertBefore(wrapper, pre);
                    wrapper.appendChild(pre);
                  }
                });
                addCopyButtons(botMsgDiv._mainContentDiv);
              }
            }
          } catch (e) {
            console.error("JSON parse error:", e, "in line:", line);
          }
        }
        maybeAutoScroll();
      }
    } catch (err) {
      console.error("Error receiving response:", err);
      if (botMsgDiv._toggleIcon) {
        botMsgDiv._toggleIcon.remove();
      }
      botMsgDiv.textContent = "[Error receiving response]";
    }
  });
</script>
